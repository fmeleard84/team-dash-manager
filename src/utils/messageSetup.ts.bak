import { supabase } from '@/integrations/supabase/client';

export interface ProjectMember {
  id: string;
  email: string;
  first_name?: string;
  last_name?: string;
  role: 'client' | 'candidate';
}

export const initializeProjectMessaging = async (projectId: string): Promise<string | null> => {
  try {
    console.log('üîÑ Initializing messaging for project:', projectId);

    // First check if messaging tables exist
    const { error: tableCheckError } = await supabase
      .from('message_threads')
      .select('count')
      .limit(0);

    if (tableCheckError) {
      console.warn('‚ö†Ô∏è Messaging tables do not exist:', tableCheckError.message);
      throw new Error('Messaging system not yet configured. Please contact administrator.');
    }

    // 1. R√©cup√©rer les d√©tails du projet
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('title, owner_id')
      .eq('id', projectId)
      .single();

    if (projectError) throw projectError;

    // 2. R√©cup√©rer les membres de l'√©quipe (candidats confirm√©s)
    const { data: projectBookings, error: bookingsError } = await supabase
      .from('project_bookings')
      .select(`
        candidate_id,
        candidate_profiles!inner (
          id,
          email,
          first_name,
          last_name
        )
      `)
      .eq('project_id', projectId)
      .eq('status', 'accepted');

    if (bookingsError) throw bookingsError;

    // 3. R√©cup√©rer le propri√©taire du projet
    const { data: ownerProfile, error: ownerError } = await supabase
      .from('profiles')
      .select('id, email, first_name, last_name')
      .eq('id', project.owner_id)
      .single();

    if (ownerError) throw ownerError;

    // 4. V√©rifier s'il existe d√©j√† un thread principal pour ce projet
    const { data: existingThread, error: threadCheckError } = await supabase
      .from('message_threads')
      .select('id')
      .eq('project_id', projectId)
      .eq('title', `√âquipe ${project.title}`)
      .single();

    if (threadCheckError && threadCheckError.code !== 'PGRST116') {
      throw threadCheckError;
    }

    let threadId: string;

    if (existingThread) {
      threadId = existingThread.id;
      console.log('‚úÖ Thread already exists:', threadId);
    } else {
      // 5. Cr√©er le thread principal de l'√©quipe
      const { data: newThread, error: createThreadError } = await supabase
        .from('message_threads')
        .insert({
          project_id: projectId,
          title: `√âquipe ${project.title}`,
          description: 'Conversation principale de l\'√©quipe du projet',
          created_by: ownerProfile.id,
          last_message_at: new Date().toISOString(),
          is_active: true
        })
        .select()
        .single();

      if (createThreadError) throw createThreadError;
      threadId = newThread.id;
      console.log('‚úÖ Thread created:', threadId);
    }

    // 6. Pr√©parer la liste des participants
    const participants = [];

    // Ajouter le propri√©taire du projet
    participants.push({
      thread_id: threadId,
      user_id: ownerProfile.id,
      email: ownerProfile.email,
      name: `${ownerProfile.first_name || ''} ${ownerProfile.last_name || ''}`.trim() || ownerProfile.email,
      role: 'client' as const,
      joined_at: new Date().toISOString(),
      is_active: true
    });

    // Ajouter les candidats
    (projectBookings || []).forEach((booking: any) => {
      if (booking.candidate_profiles) {
        participants.push({
          thread_id: threadId,
          user_id: booking.candidate_profiles.id,
          email: booking.candidate_profiles.email,
          name: `${booking.candidate_profiles.first_name || ''} ${booking.candidate_profiles.last_name || ''}`.trim() || booking.candidate_profiles.email,
          role: 'candidate' as const,
          joined_at: new Date().toISOString(),
          is_active: true
        });
      }
    });

    // 7. Ajouter/mettre √† jour les participants avec upsert
    if (participants.length > 0) {
      const { error: participantsError } = await supabase
        .from('message_participants')
        .upsert(participants, { 
          onConflict: 'thread_id,email',
          ignoreDuplicates: false 
        });

      if (participantsError) throw participantsError;
    }

    console.log('‚úÖ Messaging initialized with', participants.length, 'participants');
    return threadId;

  } catch (error) {
    console.error('‚ùå Error initializing project messaging:', error);
    throw error;
  }
};

export const sendMessage = async (
  threadId: string,
  content: string,
  attachments: Array<{ name: string; url: string; path: string; size: number; type: string }> = [],
  recipientId?: string,
  projectId?: string
): Promise<any> => {
  try {
    // R√©cup√©rer l'utilisateur actuel
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('User not authenticated');

    // R√©cup√©rer le profil de l'utilisateur
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('first_name, last_name, email')
      .eq('id', user.id)
      .single();

    if (profileError) throw profileError;
    
    // Get job title/position from candidate_profiles (only for candidates)
    let jobTitle = '';
    // Utiliser l'ID universel au lieu de l'email
    // Essayer de r√©cup√©rer le profil candidat (peut ne pas exister pour les clients)
    try {
      // Removed - position column doesn't exist
      const candidateProfiles = null;

      // Si on trouve un profil candidat, prendre sa position
      if (candidateProfiles && candidateProfiles.length > 0) {
        jobTitle = candidateProfiles[0].position || '';
      }
    } catch (error) {
      // Ignorer l'erreur - c'est probablement un client sans profil candidat
      console.log('No candidate profile found (normal for clients)');
    }

    // Use only first name for sender_name (job title will be shown separately in UI)
    const senderName = profile.first_name || profile.email.split('@')[0];

    // Cr√©er le message - pour l'instant sans job_title car la colonne n'existe pas encore
    // On inclut le m√©tier dans sender_name temporairement
    const displayName = jobTitle ? `${senderName} (${jobTitle})` : senderName;
    
    const { data: message, error: messageError } = await supabase
      .from('messages')
      .insert({
        thread_id: threadId,
        sender_id: user.id,
        sender_name: displayName, // Inclut le m√©tier temporairement
        sender_email: profile.email,
        content: content,
        is_edited: false,
        metadata: recipientId ? { recipient_id: recipientId } : undefined
      })
      .select()
      .single();

    if (messageError) throw messageError;

    // Ajouter les pi√®ces jointes si il y en a
    if (attachments.length > 0) {
      const attachmentData = attachments.map(att => ({
        message_id: message.id,
        file_name: att.name,
        file_path: att.path,
        file_type: att.type,
        file_size: att.size,
        uploaded_by: user.id
      }));

      const { error: attachmentError } = await supabase
        .from('message_attachments')
        .insert(attachmentData);

      if (attachmentError) throw attachmentError;
    }

    // Mettre √† jour le timestamp du thread
    await supabase
      .from('message_threads')
      .update({ last_message_at: new Date().toISOString() })
      .eq('id', threadId);

    console.log('‚úÖ Message sent successfully');

    // V√©rifier si le destinataire est une IA
    if (recipientId && recipientId.startsWith('ia_') && projectId) {
      console.log('ü§ñ Message destin√© √† une IA, pr√©paration de la r√©ponse...');

      try {
        // R√©cup√©rer l'ID de profil IA r√©el (sans le pr√©fixe ia_)
        const realProfileId = recipientId.replace('ia_', '');

        // R√©cup√©rer les informations de l'IA
        const { data: iaProfile } = await supabase
          .from('hr_profiles')
          .select('name, prompt_id')
          .eq('id', realProfileId)
          .eq('is_ai', true)
          .single();

        if (iaProfile?.prompt_id) {
          // V√©rifier d'abord si c'est une r√©ponse √† un choix pr√©c√©dent
          const { data: lastMessages } = await supabase
            .from('messages')
            .select('metadata')
            .eq('thread_id', threadId)
            .eq('sender_id', realProfileId)
            .order('created_at', { ascending: false })
            .limit(1);

          const lastMessage = lastMessages?.[0];
          const isWaitingForChoice = lastMessage?.metadata?.type === 'ai_choice_request';

          if (isWaitingForChoice) {
            // Traiter la r√©ponse au choix
            const userChoice = content.trim().toLowerCase();
            const wantsDocument = userChoice === '1' || userChoice.includes('livrable') || userChoice.includes('document');
            const wantsDirect = userChoice === '2' || userChoice.includes('direct') || userChoice.includes('imm√©diat');

            if (wantsDocument || wantsDirect) {
              // R√©cup√©rer le message original depuis les m√©tadonn√©es
              const originalMessage = lastMessage.metadata.original_message;

              // Envoyer un message de confirmation
              const confirmMessage = wantsDocument
                ? 'üìÑ Parfait ! Je vais cr√©er un document Word et le sauvegarder dans votre Drive. Un instant...'
                : 'üí¨ Tr√®s bien ! Je vais vous r√©pondre directement ici. Un instant...';

              await supabase
                .from('messages')
                .insert({
                  thread_id: threadId,
                  sender_id: realProfileId,
                  sender_name: `${iaProfile.name} (IA)`,
                  sender_email: `${iaProfile.name.toLowerCase().replace(/\s+/g, '_')}@ia.team`,
                  content: confirmMessage,
                  is_edited: false
                });

              // Traiter la demande originale
              await handleAIResponse(threadId, realProfileId, iaProfile, originalMessage, projectId, wantsDocument);
            } else {
              // R√©ponse non valide, redemander
              await supabase
                .from('messages')
                .insert({
                  thread_id: threadId,
                  sender_id: realProfileId,
                  sender_name: `${iaProfile.name} (IA)`,
                  sender_email: `${iaProfile.name.toLowerCase().replace(/\s+/g, '_')}@ia.team`,
                  content: '‚ùì Je n\'ai pas compris votre choix. Veuillez r√©pondre avec "1" ou "livrable" pour un document, ou "2" ou "direct" pour une r√©ponse imm√©diate.',
                  is_edited: false,
                  metadata: lastMessage.metadata // Conserver les m√©tadonn√©es pour le prochain essai
                });
            }
          } else {
            // Analyser le message pour d√©tecter si c'est une demande de cr√©ation
            const isCreationRequest = content.toLowerCase().includes('article') ||
                                     content.toLowerCase().includes('document') ||
                                     content.toLowerCase().includes('cr√©er') ||
                                     content.toLowerCase().includes('r√©diger') ||
                                     content.toLowerCase().includes('√©crire');

            // Si c'est potentiellement une demande de cr√©ation, demander le choix
            if (isCreationRequest) {
              // Cr√©er un message de demande de choix
              const choiceMessage = await supabase
                .from('messages')
                .insert({
                  thread_id: threadId,
                  sender_id: realProfileId,
                  sender_name: `${iaProfile.name} (IA)`,
                  sender_email: `${iaProfile.name.toLowerCase().replace(/\s+/g, '_')}@ia.team`,
                  content: `üìù Je d√©tecte une demande de cr√©ation de contenu.\n\nComment souhaitez-vous recevoir le r√©sultat ?\n\n1Ô∏è‚É£ **Livrable** : Je cr√©erai un document Word dans votre Drive (dossier IA)\n2Ô∏è‚É£ **R√©ponse imm√©diate** : Je vous r√©ponds directement ici\n\nR√©pondez avec "1" ou "livrable" pour un document, ou "2" ou "direct" pour une r√©ponse imm√©diate.`,
                  is_edited: false,
                  metadata: {
                    type: 'ai_choice_request',
                    original_message: content,
                    prompt_id: iaProfile.prompt_id,
                    project_id: projectId
                  }
                })
                .select()
                .single();

              console.log('ü§ñ Message de choix envoy√©');
            } else {
              // Pour les messages simples, r√©pondre directement
              await handleAIResponse(threadId, realProfileId, iaProfile, content, projectId, false);
            }
          }
        }
      } catch (aiError) {
        console.error('‚ùå Erreur lors du traitement IA:', aiError);
        // Ne pas faire √©chouer l'envoi du message original
      }
    }

    // Return the created message so it can be added immediately to the UI
    return message;

  } catch (error) {
    console.error('‚ùå Error sending message:', error);
    throw error;
  }
};

// Fonction helper pour g√©rer la r√©ponse IA
async function handleAIResponse(
  threadId: string,
  iaProfileId: string,
  iaProfile: any,
  userMessage: string,
  projectId: string,
  createDocument: boolean
) {
  try {
    // R√©cup√©rer l'historique de conversation (3 derniers messages)
    const { data: conversationHistory } = await supabase
      .from('messages')
      .select('content, sender_name, sender_email, created_at')
      .eq('thread_id', threadId)
      .order('created_at', { ascending: false })
      .limit(3);

    // Appeler l'Edge Function pour g√©n√©rer la r√©ponse
    const { data: aiResponse, error: aiError } = await supabase.functions.invoke('ai-conversation-handler', {
      body: {
        promptId: iaProfile.prompt_id,
        projectId: projectId,
        userMessage: userMessage,
        conversationHistory: conversationHistory?.reverse() || [],
        requestType: createDocument ? 'document' : 'conversation'
      }
    });

    if (aiError) throw aiError;

    // Si c'est un document, le sauvegarder dans le Drive
    if (createDocument && aiResponse?.response) {
      const { data: saveResult } = await supabase.functions.invoke('save-ai-content-to-drive', {
        body: {
          projectId: projectId,
          content: aiResponse.response,
          fileName: `${iaProfile.name}_${new Date().toISOString().split('T')[0]}`,
          iaName: iaProfile.name
        }
      });

      // Cr√©er le message avec le lien vers le document
      const documentMessage = saveResult?.fileUrl
        ? `üìÑ Document cr√©√© avec succ√®s !\n\nVotre document a √©t√© sauvegard√© dans le Drive du projet (dossier IA).\n\n[T√©l√©charger le document](${saveResult.fileUrl})\n\n---\n\n${aiResponse.response.substring(0, 500)}...`
        : `üìÑ Document cr√©√© :\n\n${aiResponse.response}`;

      await supabase
        .from('messages')
        .insert({
          thread_id: threadId,
          sender_id: iaProfileId,
          sender_name: `${iaProfile.name} (IA)`,
          sender_email: `${iaProfile.name.toLowerCase().replace(/\s+/g, '_')}@ia.team`,
          content: documentMessage,
          is_edited: false,
          metadata: {
            type: 'ai_document_response',
            document_url: saveResult?.fileUrl,
            tokens_used: aiResponse.tokensUsed
          }
        });
    } else {
      // R√©ponse directe dans la conversation
      await supabase
        .from('messages')
        .insert({
          thread_id: threadId,
          sender_id: iaProfileId,
          sender_name: `${iaProfile.name} (IA)`,
          sender_email: `${iaProfile.name.toLowerCase().replace(/\s+/g, '_')}@ia.team`,
          content: aiResponse?.response || 'Je suis d√©sol√©, je n\'ai pas pu g√©n√©rer une r√©ponse.',
          is_edited: false,
          metadata: {
            type: 'ai_response',
            tokens_used: aiResponse?.tokensUsed
          }
        });
    }

    console.log('‚úÖ R√©ponse IA envoy√©e');
  } catch (error) {
    console.error('‚ùå Erreur handleAIResponse:', error);

    // Envoyer un message d'erreur
    await supabase
      .from('messages')
      .insert({
        thread_id: threadId,
        sender_id: iaProfileId,
        sender_name: `${iaProfile.name} (IA)`,
        sender_email: `${iaProfile.name.toLowerCase().replace(/\s+/g, '_')}@ia.team`,
        content: '‚ùå D√©sol√©, je rencontre un probl√®me technique. Veuillez r√©essayer plus tard.',
        is_edited: false,
        metadata: {
          type: 'ai_error',
          error: error.message
        }
      });
  }
}