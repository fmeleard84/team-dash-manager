import { supabase } from '@/integrations/supabase/client';
import { toast } from '@/hooks/use-toast';
import { expertiseProvider } from './expertise-provider';

/**
 * Outils pour la gestion des projets via l'assistant vocal
 */

// Types pour les param√®tres des outils
export interface CreateMeetingParams {
  project_id?: string;
  project_name?: string;
  title: string;
  description?: string;
  date: string;
  time: string;
  duration?: number; // en minutes
  participants?: string[];
}

export interface CreateTeamParams {
  project_id?: string;
  project_name?: string;
  project_description?: string;
  start_date?: string;
  end_date?: string;
  budget?: number;
  profiles: Array<{
    profession: string;
    seniority: 'junior' | 'medior' | 'senior' | 'expert';
    skills?: string[];
    languages?: string[];
  }>;
}

export interface CreateProjectParams {
  name: string;
  description: string;
  start_date: string;
  end_date: string;
  budget?: number;
  team?: CreateTeamParams['profiles'];
}

export interface SearchProjectParams {
  query: string;
}

export interface CreateTodoKanbanParams {
  project_id?: string;
  project_name?: string;
  title: string;
  description?: string;
  column: 'todo' | 'in_progress' | 'review' | 'done';
  priority?: 'low' | 'medium' | 'high' | 'urgent';
  assignee?: string;
}

export interface CreateEventCalendarParams {
  project_id?: string;
  project_name?: string;
  title: string;
  description?: string;
  date: string;
  time?: string;
  duration?: number;
  type: 'meeting' | 'milestone' | 'deadline' | 'review';
}

// Fonction pour cr√©er une r√©union
export async function createMeeting(params: CreateMeetingParams) {
  try {
    // Si on a un nom de projet mais pas d'ID, chercher le projet
    let projectId = params.project_id;
    if (!projectId && params.project_name) {
      const { data: projects } = await supabase
        .from('projects')
        .select('id')
        .ilike('name', `%${params.project_name}%`)
        .limit(1);
      
      if (projects && projects.length > 0) {
        projectId = projects[0].id;
      }
    }

    if (!projectId) {
      throw new Error('Projet non trouv√©. Veuillez sp√©cifier un projet valide.');
    }

    // Cr√©er l'√©v√©nement
    const eventDate = new Date(`${params.date}T${params.time}`);
    const endDate = new Date(eventDate);
    endDate.setMinutes(endDate.getMinutes() + (params.duration || 60));

    const { data, error } = await supabase
      .from('project_events')
      .insert({
        project_id: projectId,
        title: params.title,
        description: params.description || '',
        event_type: 'meeting',
        start_date: eventDate.toISOString(),
        end_date: endDate.toISOString(),
        location: 'En ligne', // Par d√©faut
        is_all_day: false
      })
      .select()
      .single();

    if (error) throw error;

    // Ajouter les participants si sp√©cifi√©s
    if (params.participants && params.participants.length > 0 && data) {
      // Ici on pourrait ajouter les participants √† la table project_event_attendees
      console.log('Participants √† ajouter:', params.participants);
    }

    // Logger l'action
    await supabase.from('ai_action_logs').insert({
      user_id: (await supabase.auth.getUser()).data.user?.id,
      action_type: 'create_meeting',
      action_data: params,
      result: data,
      status: 'success'
    });

    return {
      success: true,
      message: `R√©union "${params.title}" cr√©√©e avec succ√®s le ${params.date} √† ${params.time}`,
      data
    };

  } catch (error: any) {
    console.error('Error creating meeting:', error);
    
    // Logger l'erreur
    await supabase.from('ai_action_logs').insert({
      user_id: (await supabase.auth.getUser()).data.user?.id,
      action_type: 'create_meeting',
      action_data: params,
      status: 'failed',
      error_message: error.message
    });

    return {
      success: false,
      error: error.message || 'Erreur lors de la cr√©ation de la r√©union'
    };
  }
}

// Fonction pour cr√©er une √©quipe projet
export async function createTeam(params: CreateTeamParams) {
  console.log('üöÄ createTeam appel√© avec:', params);
  try {
    // Charger les donn√©es de r√©f√©rence
    await expertiseProvider.loadData();
    console.log('üìö Donn√©es m√©tiers charg√©es');
    
    // R√©cup√©rer l'utilisateur actuel
    const { data: userData } = await supabase.auth.getUser();
    if (!userData?.user) {
      console.error('‚ùå Utilisateur non connect√©');
      throw new Error('Utilisateur non connect√©');
    }
    console.log('üë§ Utilisateur:', userData.user.id);

    // Pour create_team, on cr√©e TOUJOURS un nouveau projet
    // On ne cherche PAS de projet existant
    let projectId = params.project_id;
    
    // Si pas de project_id fourni, cr√©er un nouveau projet
    if (!projectId && params.project_name) {
      // Calculer les dates si non fournies
      const today = new Date();
      const startDate = params.start_date || today.toISOString().split('T')[0];
      
      // Si end_date est fournie, v√©rifier qu'elle est valide et dans le futur
      let endDate = params.end_date;
      if (endDate) {
        // Parser la date pour v√©rifier si elle est valide
        const parsedEnd = new Date(endDate);
        const parsedStart = new Date(startDate);
        
        // Si la date de fin est avant ou √©gale √† la date de d√©but, c'est probablement une erreur
        // Cela peut arriver si l'IA a mal interpr√©t√© "1 semaine" comme "1 mois"
        const diffDays = Math.floor((parsedEnd.getTime() - parsedStart.getTime()) / (1000 * 60 * 60 * 24));
        
        // Si la diff√©rence est exactement 30 ou 31 jours et que l'utilisateur a dit "1 semaine"
        // on corrige √† 7 jours
        if (diffDays >= 28 && diffDays <= 31) {
          console.log('‚ö†Ô∏è Correction probable: 1 mois d√©tect√©, peut-√™tre voulu dire 1 semaine');
          // On garde la date telle quelle car on ne peut pas √™tre s√ªr
        }
      } else {
        // Par d√©faut: 90 jours
        endDate = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      }
      
      console.log('üìÖ Dates du projet:', { startDate, endDate });
      
      // Cr√©er le projet avec les m√™mes colonnes que CreateProjectModal
      const { data: newProject, error: projectError } = await supabase
        .from('projects')
        .insert({
          title: params.project_name || `Projet ${new Date().toLocaleDateString('fr-FR')}`,
          description: params.project_description || `Projet cr√©√© par l'assistant IA avec ${params.profiles.length} membres d'√©quipe`,
          project_date: startDate,
          due_date: endDate || null,
          client_budget: params.budget || null,
          owner_id: userData.user.id,
          status: 'pause'
        })
        .select()
        .single();

      if (projectError) {
        console.error('Erreur cr√©ation projet:', projectError);
        throw new Error('Impossible de cr√©er le projet');
      }

      projectId = newProject.id;
      console.log('Nouveau projet cr√©√©:', projectId);

      // G√©n√©rer les nodes et edges ReactFlow pour l'√©quipe
      const nodes = [];
      const edges = [];
      
      // Ajouter le node client au centre (comme dans Project.tsx)
      const clientNode = {
        id: 'client-node',
        type: 'clientNode',
        position: { x: 400, y: 50 },
        data: { label: 'Client' },
        draggable: false,
        deletable: false,
        selectable: false,
      };
      nodes.push(clientNode);
      
      // Cr√©er les hr_resource_assignments comme le fait saveFlow
      const resources = [];
      const radius = 250;
      const angleStep = (2 * Math.PI) / params.profiles.length;
      
      for (let i = 0; i < params.profiles.length; i++) {
        const profile = params.profiles[i];
        const angle = angleStep * i - Math.PI / 2;
        const x = 400 + radius * Math.cos(angle);
        const y = 300 + radius * Math.sin(angle);
        
        // 1. V√©rifier que le m√©tier existe dans hr_profiles
        console.log(`üîç Recherche du m√©tier: ${profile.profession}`);
        const { data: hrProfiles } = await supabase
          .from('hr_profiles')
          .select('*')
          .ilike('name', `%${profile.profession}%`)
          .limit(1);
        
        let finalProfiles = hrProfiles;
        
        // Si le m√©tier n'existe pas, l'ignorer avec un avertissement
        if (!finalProfiles || finalProfiles.length === 0) {
          console.warn(`‚ö†Ô∏è M√©tier non trouv√© dans hr_profiles: ${profile.profession}`);
          toast({
            title: "M√©tier non disponible",
            description: `Le m√©tier "${profile.profession}" n'est pas disponible dans notre syst√®me. Il sera ignor√©.`,
            variant: "destructive"
          });
          continue;
        }
        
        // 2. V√©rifier les langues si fournies
        let validLanguages = [];
        if (profile.languages && profile.languages.length > 0) {
          console.log(`üîç V√©rification des langues: ${profile.languages.join(', ')}`);
          
          // Normaliser les noms de langues (premi√®re lettre en majuscule)
          const normalizedLanguages = profile.languages.map(lang => 
            lang.charAt(0).toUpperCase() + lang.slice(1).toLowerCase()
          );
          
          const { data: languages } = await supabase
            .from('hr_languages')
            .select('id, name')
            .in('name', normalizedLanguages);
          
          if (languages && languages.length > 0) {
            validLanguages = languages.map(l => l.name);
            const invalidLanguages = normalizedLanguages.filter(l => !languages.some(lang => lang.name === l));
            if (invalidLanguages.length > 0) {
              console.warn(`‚ö†Ô∏è Langues non trouv√©es: ${invalidLanguages.join(', ')}`);
            }
          } else {
            console.warn(`‚ö†Ô∏è Aucune langue valide trouv√©e parmi: ${normalizedLanguages.join(', ')}`);
            validLanguages = ['Fran√ßais']; // Langue par d√©faut
          }
        } else {
          validLanguages = ['Fran√ßais']; // Langue par d√©faut si aucune sp√©cifi√©e
        }
        
        // 3. R√©cup√©rer TOUTES les expertises du m√©tier depuis la base
        const hrProfile = finalProfiles[0];
        // R√©cup√©rer toutes les expertises disponibles pour ce m√©tier
        const { data: availableExpertises } = await supabase
          .from('hr_expertises')
          .select('name')
          .eq('profile_id', hrProfile.id);
        console.log(`üìö Expertises disponibles pour ${hrProfile.name}:`, availableExpertises);
        
        // Si l'utilisateur a demand√© des comp√©tences sp√©cifiques, les valider
        let validExpertises = [];
        if (availableExpertises && availableExpertises.length > 0) {
          if (profile.skills && profile.skills.length > 0) {
            console.log(`üîç Comp√©tences demand√©es: ${profile.skills.join(', ')}`);
            
            // Valider les comp√©tences demand√©es contre celles disponibles
            validExpertises = profile.skills.filter(skill => 
              availableExpertises.some(exp => 
                exp.name.toLowerCase().includes(skill.toLowerCase()) || 
                skill.toLowerCase().includes(exp.name.toLowerCase())
              )
            );
            
            const invalidSkills = profile.skills.filter(s => !validExpertises.includes(s));
            if (invalidSkills.length > 0) {
              console.warn(`‚ö†Ô∏è Comp√©tences non disponibles: ${invalidSkills.join(', ')}`);
              console.warn(`  Expertises disponibles: ${availableExpertises.map(e => e.name).join(', ')}`);
            }
            
            // Si aucune comp√©tence valide n'a √©t√© trouv√©e, utiliser toutes les expertises
            if (validExpertises.length === 0) {
              console.log(`‚ú® Aucune correspondance trouv√©e, utilisation de toutes les expertises du m√©tier`);
              validExpertises = availableExpertises.map(e => e.name);
            }
          } else {
            // Si aucune comp√©tence demand√©e, utiliser toutes celles du m√©tier
            validExpertises = availableExpertises.map(e => e.name);
            console.log(`‚ú® Utilisation de toutes les expertises du m√©tier: ${validExpertises.join(', ')}`);
          }
        } else {
          console.warn(`‚ö†Ô∏è Aucune expertise trouv√©e pour le m√©tier ${hrProfile.label}`);
          validExpertises = [];
        }
        
        const resourceId = crypto.randomUUID();
        
        console.log(`‚úÖ Cr√©ation de la ressource pour ${hrProfile.name} avec:`);
        console.log(`   - Langues valid√©es: ${validLanguages.join(', ')}`);
        console.log(`   - Expertises valid√©es: ${validExpertises.join(', ')}`);
        
        // Normaliser la s√©niorit√© avec expertise provider
        const normalizedSeniority = expertiseProvider.normalizeSeniority(profile.seniority || 'intermediate');
        console.log(`üéØ S√©niorit√© normalis√©e: ${profile.seniority} ‚Üí ${normalizedSeniority}`);
        
        // Cr√©er le node pour ReactFlow
        const resourceNode = {
          id: resourceId,
          type: 'hrResource',
          position: { x, y },
          data: {
            id: resourceId,
            profileName: hrProfile.label || hrProfile.name,
            seniority: normalizedSeniority,
            languages: [],
            expertises: [],
            calculatedPrice: hrProfile.base_price || 0,
            languageNames: validLanguages,
            expertiseNames: validExpertises,
            selected: false,
          }
        };
        nodes.push(resourceNode);
          
          // Cr√©er l'edge du client vers la ressource
          edges.push({
            id: `edge-client-${resourceId}`,
            source: 'client-node',
            target: resourceId,
            type: 'smoothstep',
            animated: false
          });
          
        // Cr√©er le hr_resource_assignment avec la structure exacte du syst√®me existant
        const { data: resource, error } = await supabase
          .from('hr_resource_assignments')
          .insert({
            id: resourceId,
            project_id: projectId,
            profile_id: hrProfile.id,
            seniority: normalizedSeniority,
            languages: validLanguages, // Utiliser les langues valid√©es
            expertises: validExpertises, // Utiliser les expertises valid√©es
            calculated_price: hrProfile.base_price || 0,
            booking_status: 'draft',
            node_data: {
              position: { x, y },
              languageNames: validLanguages,
              expertiseNames: validExpertises,
              profileName: hrProfile.name,
              is_ai: false,
              is_team_member: false
            }
          })
          .select()
          .single();
          
        if (!error && resource) {
          resources.push(resource);
          console.log('‚úÖ Ressource cr√©√©e:', resource.id);
        } else if (error) {
          console.error('‚ùå Erreur cr√©ation ressource:', error);
        }
      }
      
      // Sauvegarder les nodes et edges dans project_flows (comme saveFlow)
      if (nodes.length > 1) { // Plus que juste le client node
        const { error: flowError } = await supabase
          .from('project_flows')
          .insert({
            project_id: projectId,
            nodes: nodes,
            edges: edges
          });
        
        if (flowError) {
          console.error('Erreur cr√©ation project_flows:', flowError);
          // Pas grave si √ßa √©choue, les hr_resource_assignments suffisent pour reconstruire
        }
      }

      // Logger l'action r√©ussie (ignorer les erreurs de log)
      try {
        await supabase.from('ai_action_logs').insert({
          user_id: userData.user.id,
          action_type: 'create_team',
          action_data: params,
          result: { project_id: projectId, resources: resources },
          status: 'success'
        });
      } catch (logError) {
        console.log('Log error (ignored):', logError);
      }

      // Retourner les donn√©es avec l'URL pour naviguer vers le projet
      return {
        success: true,
        message: `Projet "${newProject.title}" cr√©√© avec une √©quipe de ${resources.length} membres`,
        data: {
          project_id: projectId,
          project_name: newProject.title,
          project_url: `/project/${projectId}`,
          resources: resources
        }
      };
    }

    // Si on arrive ici, on a un project_id mais pas de project_name
    // C'est un cas d'erreur
    return {
      success: false,
      error: 'Param√®tres invalides : project_name requis pour cr√©er un projet'
    };

  } catch (error: any) {
    console.error('Error creating team:', error);
    
    // Logger l'erreur (ignorer les erreurs de log)
    try {
      const { data: userData } = await supabase.auth.getUser();
      if (userData?.user) {
        await supabase.from('ai_action_logs').insert({
          user_id: userData.user.id,
          action_type: 'create_team',
          action_data: params,
          status: 'failed',
          error_message: error.message
        });
      }
    } catch (logError) {
      console.log('Log error (ignored):', logError);
    }

    return {
      success: false,
      error: error.message || 'Erreur lors de la cr√©ation de l\'√©quipe'
    };
  }
}

// Fonction pour cr√©er un projet complet
export async function createProject(params: CreateProjectParams) {
  try {
    const { data: userData } = await supabase.auth.getUser();
    if (!userData.user) throw new Error('Utilisateur non connect√©');

    // Cr√©er le projet
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .insert({
        title: params.name,
        description: params.description,
        project_date: params.start_date,
        due_date: params.end_date || null,
        client_budget: params.budget || null,
        status: 'pause',
        owner_id: userData.user.id
      })
      .select()
      .single();

    if (projectError) throw projectError;

    // Si une √©quipe est d√©finie, la cr√©er
    if (params.team && params.team.length > 0) {
      await createTeam({
        project_id: project.id,
        profiles: params.team
      });
    }

    // Logger l'action
    await supabase.from('ai_action_logs').insert({
      user_id: userData.user.id,
      action_type: 'create_project',
      action_data: params,
      result: project,
      status: 'success'
    });

    return {
      success: true,
      message: `Projet "${params.name}" cr√©√© avec succ√®s`,
      data: project
    };

  } catch (error: any) {
    console.error('Error creating project:', error);
    
    // Logger l'erreur
    const { data: userData } = await supabase.auth.getUser();
    if (userData.user) {
      await supabase.from('ai_action_logs').insert({
        user_id: userData.user.id,
        action_type: 'create_project',
        action_data: params,
        status: 'failed',
        error_message: error.message
      });
    }

    return {
      success: false,
      error: error.message || 'Erreur lors de la cr√©ation du projet'
    };
  }
}

// Fonction pour rechercher un projet
export async function searchProject(params: SearchProjectParams) {
  try {
    const { data: projects, error } = await supabase
      .from('projects')
      .select('id, title, description, status, project_date, due_date')
      .ilike('title', `%${params.query}%`)
      .limit(5);

    if (error) throw error;

    return {
      success: true,
      message: `${projects.length} projet(s) trouv√©(s)`,
      data: projects
    };

  } catch (error: any) {
    console.error('Error searching projects:', error);
    return {
      success: false,
      error: error.message || 'Erreur lors de la recherche'
    };
  }
}

// Fonction pour cr√©er une t√¢che dans le kanban
export async function createTodoKanban(params: CreateTodoKanbanParams) {
  console.log('üìã createTodoKanban appel√© avec:', params);
  try {
    // R√©cup√©rer l'utilisateur actuel
    const { data: userData } = await supabase.auth.getUser();
    if (!userData?.user) {
      throw new Error('Utilisateur non connect√©');
    }

    // Si on a un nom de projet mais pas d'ID, chercher le projet
    let projectId = params.project_id;
    if (!projectId && params.project_name) {
      const { data: projects } = await supabase
        .from('projects')
        .select('id')
        .ilike('name', `%${params.project_name}%`)
        .limit(1);
      
      if (projects && projects.length > 0) {
        projectId = projects[0].id;
      }
    }

    if (!projectId) {
      throw new Error('Projet non trouv√©. Veuillez sp√©cifier un projet valide.');
    }

    // Cr√©er la t√¢che dans le kanban
    const { data, error } = await supabase
      .from('kanban_tasks')
      .insert({
        project_id: projectId,
        title: params.title,
        description: params.description || '',
        column: params.column,
        priority: params.priority || 'medium',
        assigned_to: params.assignee,
        created_by: userData.user.id
      })
      .select()
      .single();

    if (error) throw error;

    // Logger l'action
    await supabase.from('ai_action_logs').insert({
      user_id: userData.user.id,
      action_type: 'create_todo_kanban',
      action_data: params,
      result: data,
      status: 'success'
    });

    console.log('‚úÖ T√¢che kanban cr√©√©e:', data);

    return {
      success: true,
      message: `T√¢che "${params.title}" cr√©√©e dans la colonne ${params.column}`,
      data
    };

  } catch (error: any) {
    console.error('Error creating kanban task:', error);
    
    // Logger l'erreur
    const { data: userData } = await supabase.auth.getUser();
    if (userData?.user) {
      await supabase.from('ai_action_logs').insert({
        user_id: userData.user.id,
        action_type: 'create_todo_kanban',
        action_data: params,
        status: 'failed',
        error_message: error.message
      });
    }

    return {
      success: false,
      error: error.message || 'Erreur lors de la cr√©ation de la t√¢che'
    };
  }
}

// Fonction pour cr√©er un √©v√©nement dans le calendrier
export async function createEventCalendar(params: CreateEventCalendarParams) {
  console.log('üìÖ createEventCalendar appel√© avec:', params);
  try {
    // R√©cup√©rer l'utilisateur actuel
    const { data: userData } = await supabase.auth.getUser();
    if (!userData?.user) {
      throw new Error('Utilisateur non connect√©');
    }

    // Si on a un nom de projet mais pas d'ID, chercher le projet
    let projectId = params.project_id;
    if (!projectId && params.project_name) {
      const { data: projects } = await supabase
        .from('projects')
        .select('id')
        .ilike('name', `%${params.project_name}%`)
        .limit(1);
      
      if (projects && projects.length > 0) {
        projectId = projects[0].id;
      }
    }

    if (!projectId) {
      throw new Error('Projet non trouv√©. Veuillez sp√©cifier un projet valide.');
    }

    // Cr√©er l'√©v√©nement
    const eventDate = params.time 
      ? new Date(`${params.date}T${params.time}`)
      : new Date(`${params.date}T09:00:00`); // Par d√©faut 9h du matin
    
    const endDate = new Date(eventDate);
    endDate.setMinutes(endDate.getMinutes() + (params.duration || 60));

    const { data, error } = await supabase
      .from('project_events')
      .insert({
        project_id: projectId,
        title: params.title,
        description: params.description || '',
        event_type: params.type,
        start_date: eventDate.toISOString(),
        end_date: endDate.toISOString(),
        location: params.type === 'meeting' ? 'En ligne' : '',
        is_all_day: !params.time
      })
      .select()
      .single();

    if (error) throw error;

    // Logger l'action
    await supabase.from('ai_action_logs').insert({
      user_id: userData.user.id,
      action_type: 'create_event_calendar',
      action_data: params,
      result: data,
      status: 'success'
    });

    console.log('‚úÖ √âv√©nement calendrier cr√©√©:', data);

    return {
      success: true,
      message: `√âv√©nement "${params.title}" cr√©√© le ${params.date}`,
      data
    };

  } catch (error: any) {
    console.error('Error creating calendar event:', error);
    
    // Logger l'erreur
    const { data: userData } = await supabase.auth.getUser();
    if (userData?.user) {
      await supabase.from('ai_action_logs').insert({
        user_id: userData.user.id,
        action_type: 'create_event_calendar',
        action_data: params,
        status: 'failed',
        error_message: error.message
      });
    }

    return {
      success: false,
      error: error.message || 'Erreur lors de la cr√©ation de l\'√©v√©nement'
    };
  }
}

// Fonction pour obtenir les FAQ
export async function getFAQ(query?: string) {
  try {
    let queryBuilder = supabase
      .from('ai_faq')
      .select('*')
      .eq('is_active', true)
      .order('order_index', { ascending: true });

    if (query) {
      queryBuilder = queryBuilder.or(`question.ilike.%${query}%,answer.ilike.%${query}%,tags.cs.{${query}}`);
    }

    const { data: faqs, error } = await queryBuilder.limit(5);

    if (error) throw error;

    return {
      success: true,
      data: faqs
    };

  } catch (error: any) {
    console.error('Error getting FAQs:', error);
    return {
      success: false,
      error: error.message || 'Erreur lors de la r√©cup√©ration des FAQ'
    };
  }
}